{"version":3,"sources":["../../src/services/process.service.ts"],"sourcesContent":["import { Area, EntriesOnProcess, OutputsOnProcess, PrismaClient, Process } from '@prisma/client';\nimport { HttpException } from '@exceptions/HttpException';\nimport { isEmpty } from '@utils/util';\nimport { CreateProcessDto, GetFilteredProcessesDto } from '@/dtos/process.dto';\n\nclass ProcessService {\n  public processes = new PrismaClient().process;\n\n  public async getAll(): Promise<Process[]> {\n    const all: Process[] = await this.processes.findMany({\n      orderBy: {\n        id: 'asc',\n      },\n      where: { active: true },\n    });\n    return all;\n  }\n\n  public async getGivenAreaAndGroup(areaId: number, groupId: number): Promise<Process[]> {\n    const filteredProcess: Process[] = await this.processes.findMany({ where: { areaId: areaId, groupId: groupId } });\n    return filteredProcess;\n  }\n\n  public async getGivenId(id: number): Promise<\n    Process & {\n      entries: EntriesOnProcess[];\n      outputs: OutputsOnProcess[];\n    }\n  > {\n    if (isEmpty(id)) throw new HttpException(400, 'id is empty');\n\n    const findProcess = await this.processes.findUnique({\n      where: { id: id },\n      include: {\n        entries: {\n          include: {\n            entry: true,\n          },\n        },\n        outputs: {\n          include: {\n            output: true,\n          },\n        },\n        tools: {\n          include: {\n            tool: true,\n          },\n        },\n      },\n    });\n\n    if (!findProcess || (findProcess && !findProcess.active)) throw new HttpException(409, \"Area doesn't exist\");\n\n    return findProcess;\n  }\n\n  public async create(data: CreateProcessDto): Promise<Process> {\n    if (isEmpty(data)) throw new HttpException(400, 'userData is empty');\n\n    data.areaId = Number(data.areaId);\n    data.groupId = Number(data.groupId);\n\n    const findProcess: Process = await this.processes.findUnique({ where: { name: data.name } });\n    if (findProcess || (findProcess && !findProcess.active)) throw new HttpException(409, `Process with title ${data.name} already exists`);\n\n    const connectEntries = Array.from(\n      data.existingEntries.map(id => {\n        return {\n          entry: {\n            connect: {\n              id: id,\n            },\n          },\n        };\n      }),\n    );\n\n    const newEntries = Array.from(\n      data.newEntries.map(newEntry => {\n        return {\n          entry: {\n            create: {\n              ...newEntry,\n            },\n          },\n        };\n      }),\n    );\n\n    const connectOutputs = Array.from(\n      data.existingOutputs.map(id => {\n        return {\n          output: {\n            connect: {\n              id: id,\n            },\n          },\n        };\n      }),\n    );\n\n    const newOutputs = Array.from(\n      data.newOutputs.map(newOutput => {\n        return {\n          output: {\n            create: {\n              ...newOutput,\n            },\n          },\n        };\n      }),\n    );\n\n    const newTestOutputs = Array.from(\n      data.newOutputs.map(newOutput => {\n        return {\n          isExit: true,\n          output: {\n            create: {\n              ...newOutput,\n            },\n          },\n        };\n      }),\n    );\n\n    const testConnectOutputs = Array.from(\n      data.existingOutputs.map(id => {\n        return {\n          entry: {\n            isExit: true,\n            connect: {\n              id: id,\n            },\n          },\n        };\n      }),\n    );\n\n    const connectTools = Array.from(\n      data.existingTools.map(id => {\n        return {\n          tool: {\n            connect: {\n              id: id,\n            },\n          },\n        };\n      }),\n    );\n\n    const newTools = Array.from(\n      data.newTools.map(newTool => {\n        return {\n          tool: {\n            create: {\n              ...newTool,\n            },\n          },\n        };\n      }),\n    );\n\n    const finalData = {\n      name: data.name,\n      areaId: data.areaId,\n      groupId: data.groupId,\n      entries: {\n        create: [...newEntries, ...connectEntries, ...newTestOutputs, ...testConnectOutputs],\n      },\n      outputs: {\n        create: [...newOutputs, ...connectOutputs],\n      },\n      tools: {\n        create: [...newTools, ...connectTools],\n      },\n    };\n\n    // @ts-ignore\n    const createData: Process = await this.processes.create({ data: { ...finalData } });\n    return createData;\n  }\n\n  public async update(id: number, data: CreateProcessDto): Promise<Process> {\n    if (isEmpty(data)) throw new HttpException(400, 'userData is empty');\n\n    const findProcess: Process = await this.processes.findUnique({\n      where: { id: id },\n      include: {\n        entries: {\n          include: {\n            entry: true,\n          },\n        },\n        // outputs: {\n        //   include: {\n        //     output: true,\n        //   },\n        // },\n      },\n    });\n\n    if (!findProcess || (findProcess && !findProcess.active)) throw new HttpException(409, \"User doesn't exist\");\n\n    const oldEntries = await new PrismaClient().entriesOnProcess.findMany({\n      where: { processId: id, isExit: false },\n    });\n\n    const oldOutputs = await new PrismaClient().entriesOnProcess.findMany({\n      where: { processId: id, isExit: true },\n    });\n\n    // let testOldOutputs = await new PrismaClient().entriesOnProcess.findMany({\n    //   where: { processId: id, isExit: true },\n    // });\n\n    const oldTools = await new PrismaClient().toolsOnProcess.findMany({\n      where: { processId: id },\n    });\n\n    //TODO make a function for this\n\n    const old = new Set();\n    const updated = new Set();\n    const disconnectEntries = [];\n    const connectEntries = [];\n\n    for (const entry of data.existingEntries) {\n      updated.add(entry);\n    }\n\n    for (const entry of oldEntries) {\n      old.add(entry.entryId);\n\n      if (!updated.has(entry.entryId)) {\n        disconnectEntries.push(entry.entryId);\n      }\n    }\n\n    for (const entry of data.existingEntries) {\n      if (!old.has(entry)) {\n        connectEntries.push({ entry: { connect: { id: entry } } });\n      }\n    }\n\n    const oldOut = new Set();\n    const updatedOut = new Set();\n    const disconnectOutputs = [];\n    const connectOutputs = [];\n\n    for (const output of data.existingOutputs) {\n      updated.add(output);\n    }\n\n    for (const output of oldOutputs) {\n      old.add(output.entryId);\n\n      if (!updatedOut.has(output.entryId)) {\n        disconnectOutputs.push(output.entryId);\n      }\n    }\n\n    for (const output of data.existingOutputs) {\n      if (!oldOut.has(output)) {\n        connectOutputs.push({ isExit: true, entry: { connect: { id: output } } });\n      }\n    }\n\n    const oldToolSet = new Set();\n    const updatedTools = new Set();\n    const disconnectTools = [];\n    const connectTools = [];\n\n    for (const tool of data.existingTools) {\n      updatedTools.add(tool);\n    }\n\n    for (const tool of oldTools) {\n      oldToolSet.add(tool.toolId);\n\n      if (!updatedTools.has(tool.toolId)) {\n        disconnectTools.push(tool.toolId);\n      }\n    }\n\n    for (const tool of data.existingTools) {\n      if (!oldToolSet.has(tool)) {\n        connectTools.push({ tool: { connect: { id: tool } } });\n      }\n    }\n\n    const newTools = Array.from(\n      data.newTools.map(newTool => {\n        return {\n          tool: {\n            create: {\n              ...newTool,\n            },\n          },\n        };\n      }),\n    );\n\n    const newEntries = Array.from(\n      data.newEntries.map(newEntry => {\n        return {\n          entry: {\n            create: {\n              ...newEntry,\n            },\n          },\n        };\n      }),\n    );\n\n    const newOutputs = Array.from(\n      data.newOutputs.map(newEntry => {\n        return {\n          isExit: true,\n          entry: {\n            create: {\n              ...newEntry,\n            },\n          },\n        };\n      }),\n    );\n\n    data.areaId = Number(data.areaId);\n    data.groupId = Number(data.groupId);\n\n    const finalData = {\n      name: data.name,\n      areaId: data.areaId,\n      groupId: data.groupId,\n      entries: {\n        create: [...newEntries, ...connectEntries, ...newOutputs, ...connectOutputs],\n      },\n      // outputs: {\n      //   // create: [...newOutputs, ...connectOutputs],\n      // },\n      tools: {\n        create: [...newTools, ...connectTools],\n      },\n    };\n\n    const entryClient = new PrismaClient().entriesOnProcess;\n    const outputClient = new PrismaClient().outputsOnProcess;\n    const toolClient = new PrismaClient().toolsOnProcess;\n\n    const deleteEntries = await entryClient.deleteMany({ where: { processId: id, entryId: { in: disconnectEntries } } });\n    const deleteOutputs = await outputClient.deleteMany({ where: { processId: id, outputId: { in: disconnectOutputs } } });\n    const deleteTools = await toolClient.deleteMany({ where: { processId: id, toolId: { in: disconnectTools } } });\n\n    const newProcess = await this.processes.update({ where: { id: id }, data: { ...finalData } });\n    return newProcess;\n  }\n\n  public async delete(id: number): Promise<Process> {\n    if (isEmpty(id)) throw new HttpException(400, \"User doesn't existId\");\n\n    const findProcess: Process = await this.processes.findUnique({ where: { id: id } });\n    if (!findProcess) throw new HttpException(409, \"User doesn't exist\");\n\n    const deleteProcess = await this.processes.update({ where: { id: id }, data: { ...findProcess, active: false } });\n    return deleteProcess;\n  }\n}\n\nexport default ProcessService;\n"],"names":["ProcessService","getAll","all","processes","findMany","orderBy","id","where","active","getGivenAreaAndGroup","areaId","groupId","filteredProcess","getGivenId","isEmpty","HttpException","findProcess","findUnique","include","entries","entry","outputs","output","tools","tool","create","data","Number","name","connectEntries","Array","from","existingEntries","map","connect","newEntries","newEntry","connectOutputs","existingOutputs","newOutputs","newOutput","newTestOutputs","isExit","testConnectOutputs","connectTools","existingTools","newTools","newTool","finalData","createData","update","oldEntries","PrismaClient","entriesOnProcess","processId","oldOutputs","oldTools","toolsOnProcess","old","Set","updated","disconnectEntries","add","entryId","has","push","oldOut","updatedOut","disconnectOutputs","oldToolSet","updatedTools","disconnectTools","toolId","entryClient","outputClient","outputsOnProcess","toolClient","deleteEntries","deleteMany","in","deleteOutputs","outputId","deleteTools","newProcess","delete","deleteProcess","process"],"mappings":"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"}