{"version":3,"sources":["../../src/services/process.service.ts"],"sourcesContent":["import { Area, EntriesOnProcess, OutputsOnProcess, PrismaClient, Process } from '@prisma/client';\nimport { HttpException } from '@exceptions/HttpException';\nimport { isEmpty } from '@utils/util';\nimport { CreateProcessDto, GetFilteredProcessesDto } from '@/dtos/process.dto';\n\nclass ProcessService {\n  public processes = new PrismaClient().process;\n\n  public async getAll(): Promise<Process[]> {\n    const all: Process[] = await this.processes.findMany({\n      orderBy: {\n        id: 'asc',\n      },\n    });\n    return all;\n  }\n\n  public async getGivenAreaAndGroup(areaId: number, groupId: number): Promise<Process[]> {\n    const filteredProcess: Process[] = await this.processes.findMany({ where: { areaId: areaId, groupId: groupId } });\n    return filteredProcess;\n  }\n\n  public async getGivenId(id: number): Promise<\n    Process & {\n      entries: EntriesOnProcess[];\n      outputs: OutputsOnProcess[];\n    }\n  > {\n    if (isEmpty(id)) throw new HttpException(400, 'id is empty');\n\n    const findProcess = await this.processes.findUnique({\n      where: { id: id },\n      include: {\n        entries: {\n          include: {\n            entry: true,\n          },\n        },\n        outputs: {\n          include: {\n            output: true,\n          },\n        },\n        tools: {\n          include: {\n            tool: true,\n          },\n        },\n      },\n    });\n\n    if (!findProcess) throw new HttpException(409, \"Area doesn't exist\");\n\n    return findProcess;\n  }\n\n  public async create(data: CreateProcessDto): Promise<Process> {\n    if (isEmpty(data)) throw new HttpException(400, 'userData is empty');\n\n    data.areaId = Number(data.areaId);\n    data.groupId = Number(data.groupId);\n\n    const findProcess: Process = await this.processes.findUnique({ where: { name: data.name } });\n    if (findProcess) throw new HttpException(409, `Process with title ${data.name} already exists`);\n\n    const connectEntries = Array.from(\n      data.existingEntries.map(id => {\n        return {\n          entry: {\n            connect: {\n              id: id,\n            },\n          },\n        };\n      }),\n    );\n\n    const newEntries = Array.from(\n      data.newEntries.map(newEntry => {\n        return {\n          entry: {\n            create: {\n              ...newEntry,\n            },\n          },\n        };\n      }),\n    );\n\n    const connectOutputs = Array.from(\n      data.existingOutputs.map(id => {\n        return {\n          output: {\n            connect: {\n              id: id,\n            },\n          },\n        };\n      }),\n    );\n\n    const newOutputs = Array.from(\n      data.newOutputs.map(newOutput => {\n        return {\n          output: {\n            create: {\n              ...newOutput,\n            },\n          },\n        };\n      }),\n    );\n\n    const connectTools = Array.from(\n      data.existingTools.map(id => {\n        return {\n          tool: {\n            connect: {\n              id: id,\n            },\n          },\n        };\n      }),\n    );\n\n    const newTools = Array.from(\n      data.newTools.map(newTool => {\n        return {\n          tool: {\n            create: {\n              ...newTool,\n            },\n          },\n        };\n      }),\n    );\n\n    const finalData = {\n      name: data.name,\n      areaId: data.areaId,\n      groupId: data.groupId,\n      entries: {\n        create: [...newEntries, ...connectEntries],\n      },\n      outputs: {\n        create: [...newOutputs, ...connectOutputs],\n      },\n      tools: {\n        create: [...newTools, ...connectTools],\n      },\n    };\n\n    // @ts-ignore\n    const createData: Process = await this.processes.create({ data: { ...finalData } });\n    return createData;\n  }\n\n  public async update(id: number, data: CreateProcessDto): Promise<Process> {\n    if (isEmpty(data)) throw new HttpException(400, 'userData is empty');\n\n    const findProcess: Process = await this.processes.findUnique({\n      where: { id: id },\n      include: {\n        entries: {\n          include: {\n            entry: true,\n          },\n        },\n        outputs: {\n          include: {\n            output: true,\n          },\n        },\n      },\n    });\n\n    if (!findProcess) throw new HttpException(409, \"User doesn't exist\");\n\n    let oldEntries = await new PrismaClient().entriesOnProcess.findMany({\n      where: { processId: id },\n    });\n\n    let oldOutputs = await new PrismaClient().outputsOnProcess.findMany({\n      where: { processId: id },\n    });\n\n    let oldTools = await new PrismaClient().toolsOnProcess.findMany({\n      where: { processId: id },\n    });\n\n    //TODO make a function for this\n\n    let old = new Set();\n    let updated = new Set();\n    let disconnectEntries = [];\n    let connectEntries = [];\n\n    for (let entry of data.existingEntries) {\n      updated.add(entry);\n    }\n\n    for (let entry of oldEntries) {\n      old.add(entry.entryId);\n\n      if (!updated.has(entry.entryId)) {\n        disconnectEntries.push(entry.entryId);\n      }\n    }\n\n    for (let entry of data.existingEntries) {\n      if (!old.has(entry)) {\n        connectEntries.push({ entry: { connect: { id: entry } } });\n      }\n    }\n\n    let oldOut = new Set();\n    let updatedOut = new Set();\n    let disconnectOutputs = [];\n    let connectOutputs = [];\n\n    for (let output of data.existingOutputs) {\n      updated.add(output);\n    }\n\n    for (let output of oldOutputs) {\n      old.add(output.outputId);\n\n      if (!updatedOut.has(output.outputId)) {\n        disconnectOutputs.push(output.outputId);\n      }\n    }\n\n    for (let output of data.existingOutputs) {\n      if (!oldOut.has(output)) {\n        connectOutputs.push({ output: { connect: { id: output } } });\n      }\n    }\n\n    let oldToolSet = new Set();\n    let updatedTools = new Set();\n    let disconnectTools = [];\n    let connectTools = [];\n\n    for (let tool of data.existingTools) {\n      updatedTools.add(tool);\n    }\n\n    for (let tool of oldTools) {\n      oldToolSet.add(tool.toolId);\n\n      if (!updatedTools.has(tool.toolId)) {\n        disconnectTools.push(tool.toolId);\n      }\n    }\n\n    for (let tool of data.existingTools) {\n      if (!oldToolSet.has(tool)) {\n        connectTools.push({ tool: { connect: { id: tool } } });\n      }\n    }\n\n    let newTools = Array.from(\n      data.newTools.map(newTool => {\n        return {\n          tool: {\n            create: {\n              ...newTool,\n            },\n          },\n        };\n      }),\n    );\n\n    let newEntries = Array.from(\n      data.newEntries.map(newEntry => {\n        return {\n          entry: {\n            create: {\n              ...newEntry,\n            },\n          },\n        };\n      }),\n    );\n\n    let newOutputs = Array.from(\n      data.newOutputs.map(newOutput => {\n        return {\n          output: {\n            create: {\n              ...newOutput,\n            },\n          },\n        };\n      }),\n    );\n\n    data.areaId = Number(data.areaId);\n    data.groupId = Number(data.groupId);\n\n    let finalData = {\n      name: data.name,\n      areaId: data.areaId,\n      groupId: data.groupId,\n      entries: {\n        create: [...newEntries, ...connectEntries],\n      },\n      outputs: {\n        create: [...newOutputs, ...connectOutputs],\n      },\n      tools: {\n        create: [...newTools, ...connectTools],\n      },\n    };\n\n    let entryClient = new PrismaClient().entriesOnProcess;\n    let outputClient = new PrismaClient().outputsOnProcess;\n    let toolClient = new PrismaClient().toolsOnProcess;\n\n    let deleteEntries = await entryClient.deleteMany({ where: { processId: id, entryId: { in: disconnectEntries } } });\n    let deleteOutputs = await outputClient.deleteMany({ where: { processId: id, outputId: { in: disconnectOutputs } } });\n    let deleteTools = await toolClient.deleteMany({ where: { processId: id, toolId: { in: disconnectTools } } });\n\n    const newProcess = await this.processes.update({ where: { id: id }, data: { ...finalData } });\n    return newProcess;\n  }\n\n  public async delete(id: number): Promise<Process> {\n    if (isEmpty(id)) throw new HttpException(400, \"User doesn't existId\");\n\n    const findProcess: Process = await this.processes.findUnique({ where: { id: id } });\n    if (!findProcess) throw new HttpException(409, \"User doesn't exist\");\n\n    const deleteProcess = await this.processes.delete({ where: { id: id } });\n    return deleteProcess;\n  }\n}\n\nexport default ProcessService;\n"],"names":["ProcessService","getAll","all","processes","findMany","orderBy","id","getGivenAreaAndGroup","areaId","groupId","filteredProcess","where","getGivenId","isEmpty","HttpException","findProcess","findUnique","include","entries","entry","outputs","output","tools","tool","create","data","Number","name","connectEntries","Array","from","existingEntries","map","connect","newEntries","newEntry","connectOutputs","existingOutputs","newOutputs","newOutput","connectTools","existingTools","newTools","newTool","finalData","createData","update","oldEntries","PrismaClient","entriesOnProcess","processId","oldOutputs","outputsOnProcess","oldTools","toolsOnProcess","old","Set","updated","disconnectEntries","add","entryId","has","push","oldOut","updatedOut","disconnectOutputs","outputId","oldToolSet","updatedTools","disconnectTools","toolId","entryClient","outputClient","toolClient","deleteEntries","deleteMany","in","deleteOutputs","deleteTools","newProcess","delete","deleteProcess","process"],"mappings":"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"}