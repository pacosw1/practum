{"version":3,"sources":["../../src/services/process.service.ts"],"sourcesContent":["import { Area, EntriesOnProcess, OutputsOnProcess, PrismaClient, Process } from '@prisma/client';\nimport { HttpException } from '@exceptions/HttpException';\nimport { isEmpty } from '@utils/util';\nimport { CreateProcessDto, GetFilteredProcessesDto } from '@/dtos/process.dto';\n\nclass ProcessService {\n  public processes = new PrismaClient().process;\n\n\n  public async getAll(): Promise<Process[]> {\n    const all: Process[] = await this.processes.findMany();\n    return all;\n  }\n\n  public async getGivenAreaAndGroup(areaId: number, groupId: number): Promise<Process[]> {\n    const filteredProcess: Process[] = await this.processes.findMany({ where: { areaId: areaId, groupId: groupId } });\n    return filteredProcess;\n  }\n\n  public async getGivenId(id: number): Promise<Process & {\n    entries: EntriesOnProcess[];\n    outputs: OutputsOnProcess[];\n}> {\n    if (isEmpty(id)) throw new HttpException(400, 'id is empty');\n\n    const findProcess = await this.processes.findUnique({ where: { id: id }, include: {\n        entries: {\n          include: {\n            entry: true\n          }\n        },\n        outputs: {\n          include: {\n            output: true\n          }\n        },\n        tools: {\n          include: {\n            tool: true\n          }\n        },\n    } });\n\n    if (!findProcess) throw new HttpException(409, \"Area doesn't exist\");\n\n    return findProcess;\n  }\n\n  public async create(data: CreateProcessDto): Promise<Process> {\n    if (isEmpty(data)) throw new HttpException(400, 'userData is empty');\n\n    data.areaId = Number(data.areaId)\n    data.groupId = Number(data.groupId)\n\n    const findProcess: Process = await this.processes.findUnique({ where: { name: data.name } });\n    if (findProcess) throw new HttpException(409, `Process with title ${data.name} already exists`);\n\n    let connectEntries = Array.from(data.existingEntries.map(id => {\n      return {\n        entry: {\n          connect: {\n            id: id\n          }\n        }\n      }\n    }))\n\n    let newEntries = Array.from(data.newEntries.map(newEntry => {\n        return {\n          entry: {\n            create: {\n              ...newEntry\n            }\n          }\n        }\n    }))\n\n    let connectOutputs = Array.from(data.existingOutputs.map(id => {\n      return {\n        output: {\n          connect: {\n            id: id\n          }\n        }\n      }\n    }))\n\n    let newOutputs = Array.from(data.newOutputs.map(newOutput => {\n        return {\n          output: {\n            create: {\n              ...newOutput\n            }\n          }\n        }\n    }))\n\n    let connectTools = Array.from(data.existingTools.map(id => {\n      return {\n        tool: {\n          connect: {\n            id: id\n          }\n        }\n      }\n    }))\n\n    let newTools = Array.from(data.newTools.map(newTool => {\n        return {\n          tool: {\n            create: {\n              ...newTool\n            }\n          }\n        }\n    }))\n\n\n    let finalData = {\n      name: data.name,\n      areaId: data.areaId,\n      groupId: data.groupId,\n      entries: {\n        create: [\n          ...newEntries,\n          ...connectEntries\n        ]\n      },\n      outputs: {\n        create: [\n          ...newOutputs,\n          ...connectOutputs\n        ]\n      },\n      tools: {\n        create: [\n          ...newTools,\n          ...connectTools\n        ]\n      }\n    }\n\n    // @ts-ignore\n    const createData: Process = await this.processes.create({ data: { ...finalData } });\n    return createData;\n  }\n\n  public async update(id: number, data: CreateProcessDto): Promise<Process> {\n    if (isEmpty(data)) throw new HttpException(400, 'userData is empty');\n\n    const findProcess: Process = await this.processes.findUnique({ where: { id: id }, include: {\n      entries: {\n        include: {\n          entry: true\n        }\n      },\n      outputs: {\n        include: {\n          output: true\n        }\n      },\n    } });\n\n  \n  \n    if (!findProcess) throw new HttpException(409, \"User doesn't exist\");\n\n    let oldEntries = await new PrismaClient().entriesOnProcess.findMany({\n      where: { processId: id}\n    })\n\n    let oldOutputs = await new PrismaClient().outputsOnProcess.findMany({\n      where: { processId: id}\n    })\n\n    let oldTools = await new PrismaClient().toolsOnProcess.findMany({\n      where: { processId: id}\n    })\n\n    //TODO make a function for this\n\n    let old = new Set()\n    let updated = new Set()\n    let disconnectEntries = []\n    let connectEntries = []\n\n\n    for (let entry of data.existingEntries) {\n      updated.add(entry)\n    }\n\n    for (let entry of oldEntries) {\n      old.add(entry.entryId)\n      \n      if (!updated.has(entry.entryId)) {\n        disconnectEntries.push(entry.entryId)\n      }\n    }\n\n\n    for (let entry of data.existingEntries) {\n      if (!old.has(entry)) {\n        connectEntries.push({entry: {connect: {id: entry}}})\n      }\n    }\n\n\n    let oldOut = new Set()\n    let updatedOut = new Set()\n    let disconnectOutputs = []\n    let connectOutputs = []\n\n\n    for (let output of data.existingOutputs) {\n      updated.add(output)\n    }\n\n    for (let output of oldOutputs) {\n      old.add(output.outputId)\n      \n      if (!updatedOut.has(output.outputId)) {\n        disconnectOutputs.push(output.outputId)\n      }\n    }\n\n    for (let output of data.existingOutputs) {\n      if (!oldOut.has(output)) {\n        connectOutputs.push({output: {connect: {id: output}}})\n      }\n    }\n\n\n    let oldToolSet = new Set()\n    let updatedTools = new Set()\n    let disconnectTools = []\n    let connectTools = []\n\n\n    for (let tool of data.existingTools) {\n      updatedTools.add(tool)\n    }\n\n    for (let tool of oldTools) {\n      oldToolSet.add(tool.toolId)\n      \n      if (!updatedTools.has(tool.toolId)) {\n        disconnectTools.push(tool.toolId)\n      }\n    }\n\n    for (let tool of data.existingTools) {\n      if (!oldToolSet.has(tool)) {\n        connectTools.push({tool: {connect: {id: tool}}})\n      }\n    }\n\n    let newTools = Array.from(data.newTools.map(newTool => {\n      return {\n        tool: {\n          create: {\n            ...newTool\n          }\n        }\n      }\n  }))\n\n    let newEntries = Array.from(data.newEntries.map(newEntry => {\n        return {\n          entry: {\n            create: {\n              ...newEntry\n            }\n          }\n        }\n    }))\n\n    let newOutputs = Array.from(data.newOutputs.map(newOutput => {\n        return {\n          output: {\n            create: {\n              ...newOutput\n            }\n          }\n        }\n    }))\n\n    data.areaId = Number(data.areaId)\n    data.groupId = Number(data.groupId)\n\n    let finalData = {\n      name: data.name,\n      areaId: data.areaId,\n      groupId: data.groupId,\n      entries: {\n        create: [\n          ...newEntries,\n          ...connectEntries\n        ],\n      },\n      outputs: {\n        create: [\n          ...newOutputs,\n          ...connectOutputs\n        ],\n      },\n      tools: {\n        create: [\n          ...newTools,\n          ...connectTools\n        ],\n      },\n    }\n\n    let entryClient = new PrismaClient().entriesOnProcess\n    let outputClient = new PrismaClient().outputsOnProcess\n    let toolClient = new PrismaClient().toolsOnProcess\n\n\n    let deleteEntries = await entryClient.deleteMany({where: {processId: id, entryId: {in: disconnectEntries}}})\n    let deleteOutputs = await outputClient.deleteMany({where: {processId: id, outputId: {in: disconnectOutputs}}})\n    let deleteTools = await toolClient.deleteMany({where: {processId: id, toolId: {in: disconnectTools}}})\n\n\n    const newProcess = await this.processes.update({ where: { id: id }, data: { ...finalData} });\n    return newProcess;\n  }\n\n  public async delete(id: number): Promise<Process> {\n    if (isEmpty(id)) throw new HttpException(400, \"User doesn't existId\");\n\n    const findProcess: Process = await this.processes.findUnique({ where: { id: id } });\n    if (!findProcess) throw new HttpException(409, \"User doesn't exist\");\n\n    const deleteProcess = await this.processes.delete({ where: { id: id } });\n    return deleteProcess;\n  }\n\n}\n\nexport default ProcessService;\n"],"names":["ProcessService","getAll","all","processes","findMany","getGivenAreaAndGroup","areaId","groupId","filteredProcess","where","getGivenId","id","isEmpty","HttpException","findProcess","findUnique","include","entries","entry","outputs","output","tools","tool","create","data","Number","name","connectEntries","Array","from","existingEntries","map","connect","newEntries","newEntry","connectOutputs","existingOutputs","newOutputs","newOutput","connectTools","existingTools","newTools","newTool","finalData","createData","update","oldEntries","PrismaClient","entriesOnProcess","processId","oldOutputs","outputsOnProcess","oldTools","toolsOnProcess","old","Set","updated","disconnectEntries","add","entryId","has","push","oldOut","updatedOut","disconnectOutputs","outputId","oldToolSet","updatedTools","disconnectTools","toolId","entryClient","outputClient","toolClient","deleteEntries","deleteMany","in","deleteOutputs","deleteTools","newProcess","delete","deleteProcess","process"],"mappings":"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"}