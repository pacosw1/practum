{"version":3,"sources":["../../src/services/auth.service.ts"],"sourcesContent":["import { compare, hash } from 'bcrypt';\nimport { sign, decode, verify } from 'jsonwebtoken';\nimport { PrismaClient, User } from '@prisma/client';\nimport { SECRET_KEY } from '@config';\nimport { CreateUserDto } from '@dtos/users.dto';\nimport { HttpException } from '@exceptions/HttpException';\nimport { DataStoredInToken, TokenData } from '@interfaces/auth.interface';\nimport { isEmpty } from '@utils/util';\nimport { resolve } from 'path';\n\n// class TokenData {\n//   expiresIn: number;\n//   token: string;\n// }\n\nclass AuthService {\n  public users = new PrismaClient().user;\n\n  public async signup(userData: CreateUserDto): Promise<User> {\n    if (isEmpty(userData)) throw new HttpException(400, 'userData is empty');\n\n    const findUser: User = await this.users.findUnique({ where: { email: userData.email } });\n    if (findUser) throw new HttpException(409, `This email ${userData.email} already exists`);\n\n    const hashedPassword = await hash(userData.password, 10);\n    const createUserData: Promise<User> = this.users.create({ data: { ...userData, password: hashedPassword } });\n\n    return createUserData;\n  }\n\n  public async access(token: string): Promise<{ authenticated: Boolean; data: { id: number; email: string } }> {\n    try {\n      const secretKey: string = SECRET_KEY;\n      const verificationResponse = (await verify(token, secretKey)) as DataStoredInToken;\n      const userId = verificationResponse.id;\n\n      const users = new PrismaClient().user;\n      const findUser = await users.findUnique({ where: { id: Number(userId) } });\n\n      if (findUser) {\n        return {\n          authenticated: true,\n          data: {\n            email: findUser.email,\n            id: findUser.id,\n          },\n        };\n      } else {\n        return {\n          authenticated: false,\n          data: null,\n        };\n      }\n    } catch (err) {\n      return {\n        authenticated: false,\n        data: null,\n      };\n    }\n  }\n\n  public async login(userData: CreateUserDto): Promise<{ tokenData: TokenData; findUser: User }> {\n    if (isEmpty(userData)) throw new HttpException(400, 'userData is empty');\n\n    const findUser: User = await this.users.findUnique({ where: { email: userData.email } });\n    if (!findUser) throw new HttpException(409, `This email ${userData.email} was not found`);\n\n    const isPasswordMatching: boolean = await compare(userData.password, findUser.password);\n    if (!isPasswordMatching) throw new HttpException(409, 'Password is not matching');\n\n    const tokenData = this.createToken(findUser);\n\n    return { tokenData, findUser };\n  }\n\n  public async logout(userData: User): Promise<User> {\n    if (isEmpty(userData)) throw new HttpException(400, 'userData is empty');\n\n    const findUser: User = await this.users.findFirst({ where: { email: userData.email, password: userData.password } });\n    if (!findUser) throw new HttpException(409, \"User doesn't exist\");\n\n    return findUser;\n  }\n\n  public createToken(user: User): TokenData {\n    const dataStoredInToken: DataStoredInToken = { id: user.id };\n    const secretKey: string = SECRET_KEY;\n    const expiresIn: number = 1000 * 60 * 60 * 24 * 30; // 30 days\n\n    return { expiresIn, token: sign(dataStoredInToken, secretKey, { expiresIn }) };\n  }\n}\n\nexport default AuthService;\n"],"names":["AuthService","signup","userData","isEmpty","HttpException","findUser","users","findUnique","where","email","hashedPassword","hash","password","createUserData","create","data","access","token","secretKey","SECRET_KEY","verificationResponse","verify","userId","id","PrismaClient","user","Number","authenticated","err","login","isPasswordMatching","compare","tokenData","createToken","logout","findFirst","dataStoredInToken","expiresIn","sign"],"mappings":"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"}